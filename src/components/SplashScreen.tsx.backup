import React, { useState, useEffect, useCallback, useRef } from 'react';
import { View, StyleSheet, TouchableOpacity, Text, Platform, Alert } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import Animated, { 
  useSharedValue, 
  useAnimatedStyle, 
  withDelay, 
  withTiming, 
  withRepeat,
  Easing,
  runOnJS,
  cancelAnimation
} from 'react-native-reanimated';
import SafeImage from './SafeImage';
import { AssetKey } from '../constants/assets';
import { 
  wp, 
  hp, 
  rf, 
  rs, 
  getResponsiveDimensions, 
  getPlatformShadow, 
  getScreenCategory,
  getResponsiveSpacing,
  screenDimensions
} from '../constants/responsive';
import { useAccessibility } from '../hooks/useAccessibility';
import { 
  AccessibilityLabels, 
  AccessibilityRoles, 
  AccessibleColors,
  getAnimationDuration,
  getAccessibleAnimationConfig
} from '../constants/accessibility';
import { 
  ErrorLogger, 
  ErrorType, 
  createInitialFallbackState,
  FallbackState,
  safeNavigate
} from '../utils/errorHandling';
import { 
  detectDeviceCapabilities,
  getOptimizedAnimationConfig,
  PerformanceMonitor,
  AnimationScheduler,
  AnimationMemoryManager
} from '../utils/performanceOptimization';

// TypeScript interfaces
interface SplashScreenProps {
  onGetStarted: () => void;
}

interface AssetLoadingState {
  loadedAssets: Set<AssetKey>;
  failedAssets: Set<AssetKey>;
  isAllAssetsLoaded: boolean;
  criticalAssetsLoaded: boolean;
}

interface AnimationState {
  isAnimating: boolean;
  completedAnimations: Set<string>;
  failedAnimations: Set<string>;
}

const spacing = getResponsiveSpacing();
const screenCategory = getScreenCategory();

const SplashScreen: React.FC<SplashScreenProps> = ({ onGetStarted }) => {
  // Accessibility state
  const { isScreenReaderEnabled, isReduceMotionEnabled, isHighContrastEnabled } = useAccessibility();
  
  // Performance and device capabilities
  const deviceCapabilities = detectDeviceCapabilities();
  const [fallbackState, setFallbackState] = useState<FallbackState>(createInitialFallbackState());
  
  const [assetState, setAssetState] = useState<AssetLoadingState>({
    loadedAssets: new Set(),
    failedAssets: new Set(),
    isAllAssetsLoaded: false,
    criticalAssetsLoaded: false,
  });

  const [animationState, setAnimationState] = useState<AnimationState>({
    isAnimating: false,
    completedAnimations: new Set(),
    failedAnimations: new Set(),
  });

  // Critical assets that must load for basic functionality
  const criticalAssets: AssetKey[] = ['logo', 'text'];
  const decorativeAssets: AssetKey[] = ['pentagon', 'group', 'bubble'];
  const requiredAssets: AssetKey[] = [...criticalAssets, ...decorativeAssets];
  
  // Refs for cleanup
  const animationTimeoutRef = useRef<NodeJS.Timeout>();
  const navigationTimeoutRef = useRef<NodeJS.Timeout>();

  // Button state for press feedback
  const [isButtonPressed, setIsButtonPressed] = useState(false);

  // Animation SharedValues
  const logoScale = useSharedValue(0);
  const textTranslateX = useSharedValue(-wp(15)); // Responsive slide distance (15% of screen width)
  const textOpacity = useSharedValue(0); // Add opacity for smoother entrance
  const pentagonShimmer = useSharedValue(0.6); // Pentagon shimmer opacity
  const groupFloatY = useSharedValue(0); // Group vertical floating
  const groupShimmer = useSharedValue(0.7); // Group shimmer opacity
  
  // Bubble animation SharedValues - circular motion patterns
  const bubble1X = useSharedValue(0);
  const bubble1Y = useSharedValue(0);
  const bubble2X = useSharedValue(0);
  const bubble2Y = useSharedValue(0);
  const bubble3X = useSharedValue(0);
  const bubble3Y = useSharedValue(0);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (animationTimeoutRef.current) {
        clearTimeout(animationTimeoutRef.current);
      }
      if (navigationTimeoutRef.current) {
        clearTimeout(navigationTimeoutRef.current);
      }
      
      // Cancel all animations
      cancelAnimation(logoScale);
      cancelAnimation(textTranslateX);
      cancelAnimation(textOpacity);
      cancelAnimation(pentagonShimmer);
      cancelAnimation(groupFloatY);
      cancelAnimation(groupShimmer);
      cancelAnimation(bubble1X);
      cancelAnimation(bubble1Y);
      cancelAnimation(bubble2X);
      cancelAnimation(bubble2Y);
      cancelAnimation(bubble3X);
      cancelAnimation(bubble3Y);
      
      // Clear animation memory
      AnimationMemoryManager.clearAllAnimations();
    };
  }, []);

  // Animation error handler
  const handleAnimationError = useCallback((animationId: string, error: Error) => {
    ErrorLogger.logError(
      ErrorType.ANIMATION_FAILURE,
      `Animation ${animationId} failed`,
      error,
      { animationId, deviceCapabilities }
    );

    setAnimationState(prev => ({
      ...prev,
      failedAnimations: new Set([...prev.failedAnimations, animationId]),
    }));

    setFallbackState(prev => ({
      ...prev,
      hasAnimationErrors: true,
      degradedMode: prev.failedAnimations.size > 2, // Enter degraded mode if multiple failures
    }));
  }, [deviceCapabilities]);

  // Start animations on component mount
  useEffect(() => {
    // Only start animations if critical assets are loaded or in degraded mode
    if (!assetState.criticalAssetsLoaded && !fallbackState.degradedMode) {
      return;
    }

    PerformanceMonitor.startMonitoring();
    setAnimationState(prev => ({ ...prev, isAnimating: true }));

    // Get accessibility-aware animation configuration
    const animConfig = getAccessibleAnimationConfig(isReduceMotionEnabled);
    const optimizedConfig = getOptimizedAnimationConfig(
      { duration: 800, isReduceMotionEnabled },
      deviceCapabilities
    );
    
    // Logo pop-out animation with error handling
    const logoDelay = getAnimationDuration(300, isReduceMotionEnabled);
    const logoDuration = optimizedConfig.duration;
    
    AnimationScheduler.scheduleAnimation('logo', 10, () => {
      try {
        logoScale.value = withDelay(
          logoDelay,
          withTiming(1, {
            duration: logoDuration,
            easing: optimizedConfig.enableComplexEasing ? Easing.out(Easing.back(1.7)) : Easing.ease,
          }, (finished) => {
            if (finished) {
              runOnJS(() => {
                setAnimationState(prev => ({
                  ...prev,
                  completedAnimations: new Set([...prev.completedAnimations, 'logo']),
                }));
              })();
            }
          })
        );
      } catch (error) {
        handleAnimationError('logo', error as Error);
      }
    });

    // Text slide-in animation with error handling
    const textDelay = getAnimationDuration(1000, isReduceMotionEnabled);
    const textDuration = getAnimationDuration(600, isReduceMotionEnabled);
    
    AnimationScheduler.scheduleAnimation('text', 9, () => {
      try {
        textTranslateX.value = withDelay(
          textDelay,
          withTiming(0, {
            duration: textDuration,
            easing: optimizedConfig.enableComplexEasing ? Easing.bezier(0.25, 0.46, 0.45, 0.94) : Easing.ease,
          }, (finished) => {
            if (finished) {
              runOnJS(() => {
                setAnimationState(prev => ({
                  ...prev,
                  completedAnimations: new Set([...prev.completedAnimations, 'text']),
                }));
              })();
            }
          })
        );

        // Text opacity animation (fade in with slide)
        textOpacity.value = withDelay(
          textDelay,
          withTiming(1, {
            duration: textDuration,
            easing: optimizedConfig.enableComplexEasing ? Easing.bezier(0.25, 0.46, 0.45, 0.94) : Easing.ease,
          })
        );
      } catch (error) {
        handleAnimationError('text', error as Error);
      }
    });

    // Pentagon shimmer animation - respect reduced motion and performance
    if (optimizedConfig.shouldReduceMotion || fallbackState.hasAssetErrors) {
      // For reduced motion or asset errors, set to a static comfortable opacity
      pentagonShimmer.value = 0.8;
    } else {
      AnimationScheduler.scheduleAnimation('pentagon', 5, () => {
        try {
          pentagonShimmer.value = withRepeat(
            withTiming(1.0, {
              duration: getAnimationDuration(1000, isReduceMotionEnabled),
              easing: Easing.inOut(Easing.ease),
            }),
            -1, // Infinite repeat
            true // Reverse animation (oscillate between 0.6 and 1.0)
          );
        } catch (error) {
          handleAnimationError('pentagon', error as Error);
          pentagonShimmer.value = 0.8; // Fallback to static state
        }
      });
    }

    // Group floating animation - respect reduced motion and performance
    const groupFloatDistance = rs(10); // Responsive float distance
    if (optimizedConfig.shouldReduceMotion || fallbackState.hasAssetErrors) {
      // For reduced motion or asset errors, set to static positions
      groupFloatY.value = 0;
      groupShimmer.value = 0.85;
    } else {
      AnimationScheduler.scheduleAnimation('group', 4, () => {
        try {
          groupFloatY.value = withRepeat(
            withTiming(groupFloatDistance * (optimizedConfig.shouldReduceMotion ? 0.3 : 1.0), {
              duration: getAnimationDuration(1500, isReduceMotionEnabled),
              easing: Easing.inOut(Easing.ease),
            }),
            -1, // Infinite repeat
            true // Reverse animation
          );

          // Group shimmer animation - opacity oscillation (0.7 to 1.0)
          groupShimmer.value = withRepeat(
            withTiming(1.0, {
              duration: getAnimationDuration(1500, isReduceMotionEnabled),
              easing: Easing.inOut(Easing.ease),
            }),
            -1, // Infinite repeat
            true // Reverse animation
          );
        } catch (error) {
          handleAnimationError('group', error as Error);
          groupFloatY.value = 0;
          groupShimmer.value = 0.85;
        }
      });
    }

    // Bubble floating animations - respect reduced motion and performance
    const bubbleRadius1 = rs(15); // Responsive radius
    const bubbleRadius2 = rs(8);  // Responsive radius
    const bubbleRadius3 = rs(6);  // Responsive radius
    const animationIntensity = optimizedConfig.shouldReduceMotion ? 0.3 : 1.0;
    
    if (optimizedConfig.shouldReduceMotion || fallbackState.hasAssetErrors || deviceCapabilities.isLowEndDevice) {
      // For reduced motion, asset errors, or low-end devices, set bubbles to static positions
      bubble1X.value = 0;
      bubble1Y.value = 0;
      bubble2X.value = 0;
      bubble2Y.value = 0;
      bubble3X.value = 0;
      bubble3Y.value = 0;
    } else {
      // Bubble animations with lower priority and error handling
      AnimationScheduler.scheduleAnimation('bubble1', 2, () => {
        try {
          bubble1X.value = withDelay(
            getAnimationDuration(200, isReduceMotionEnabled),
            withRepeat(
              withTiming(bubbleRadius1 * animationIntensity, {
                duration: getAnimationDuration(2000, isReduceMotionEnabled),
                easing: Easing.inOut(Easing.ease),
              }),
              -1, true
            )
          );
          
          bubble1Y.value = withDelay(
            getAnimationDuration(200, isReduceMotionEnabled),
            withRepeat(
              withTiming(rs(10) * animationIntensity, {
                duration: getAnimationDuration(2000, isReduceMotionEnabled),
                easing: Easing.inOut(Easing.ease),
              }),
              -1, true
            )
          );
        } catch (error) {
          handleAnimationError('bubble1', error as Error);
        }
      });

      AnimationScheduler.scheduleAnimation('bubble2', 1, () => {
        try {
          bubble2X.value = withDelay(
            getAnimationDuration(800, isReduceMotionEnabled),
            withRepeat(
              withTiming(bubbleRadius2 * animationIntensity, {
                duration: getAnimationDuration(2000, isReduceMotionEnabled),
                easing: Easing.inOut(Easing.ease),
              }),
              -1, true
            )
          );
          
          bubble2Y.value = withDelay(
            getAnimationDuration(800, isReduceMotionEnabled),
            withRepeat(
              withTiming(rs(12) * animationIntensity, {
                duration: getAnimationDuration(2000, isReduceMotionEnabled),
                easing: Easing.inOut(Easing.ease),
              }),
              -1, true
            )
          );
        } catch (error) {
          handleAnimationError('bubble2', error as Error);
        }
      });

      AnimationScheduler.scheduleAnimation('bubble3', 1, () => {
        try {
          bubble3X.value = withDelay(
            getAnimationDuration(1400, isReduceMotionEnabled),
            withRepeat(
              withTiming(bubbleRadius3 * animationIntensity, {
                duration: getAnimationDuration(2000, isReduceMotionEnabled),
                easing: Easing.inOut(Easing.ease),
              }),
              -1, true
            )
          );
          
          bubble3Y.value = withDelay(
            getAnimationDuration(1400, isReduceMotionEnabled),
            withRepeat(
              withTiming(rs(8) * animationIntensity, {
                duration: getAnimationDuration(2000, isReduceMotionEnabled),
                easing: Easing.inOut(Easing.ease),
              }),
              -1, true
            )
          );
        } catch (error) {
          handleAnimationError('bubble3', error as Error);
        }
      });
    }

    // Set timeout to stop performance monitoring
    animationTimeoutRef.current = setTimeout(() => {
      PerformanceMonitor.stopMonitoring();
      setAnimationState(prev => ({ ...prev, isAnimating: false }));
    }, 5000); // Monitor for 5 seconds

  }, [isReduceMotionEnabled, assetState.criticalAssetsLoaded, fallbackState.degradedMode, handleAnimationError, deviceCapabilities, optimizedConfig]);

  const handleAssetLoad = useCallback((assetKey: AssetKey) => {
    setAssetState(prev => {
      const newLoadedAssets = new Set(prev.loadedAssets);
      newLoadedAssets.add(assetKey);
      
      const criticalLoaded = criticalAssets.every(asset => newLoadedAssets.has(asset));
      const isAllLoaded = requiredAssets.every(asset => 
        newLoadedAssets.has(asset) || prev.failedAssets.has(asset)
      );

      return {
        ...prev,
        loadedAssets: newLoadedAssets,
        criticalAssetsLoaded: criticalLoaded,
        isAllAssetsLoaded: isAllLoaded,
      };
    });
  }, [criticalAssets, requiredAssets]);

  const handleAssetError = useCallback((assetKey: AssetKey, error: Error) => {
    ErrorLogger.logError(
      ErrorType.ASSET_LOADING,
      `Asset loading failed for ${assetKey}`,
      error,
      { assetKey, isCritical: criticalAssets.includes(assetKey) }
    );

    setAssetState(prev => {
      const newFailedAssets = new Set(prev.failedAssets);
      newFailedAssets.add(assetKey);
      
      const criticalLoaded = criticalAssets.every(asset => 
        prev.loadedAssets.has(asset) || (newFailedAssets.has(asset) && criticalAssets.includes(assetKey))
      );
      const isAllLoaded = requiredAssets.every(asset => 
        prev.loadedAssets.has(asset) || newFailedAssets.has(asset)
      );

      return {
        ...prev,
        failedAssets: newFailedAssets,
        criticalAssetsLoaded: criticalLoaded,
        isAllAssetsLoaded: isAllLoaded,
      };
    });

    // Update fallback state if critical assets fail
    if (criticalAssets.includes(assetKey)) {
      setFallbackState(prev => ({
        ...prev,
        hasAssetErrors: true,
        failedAssets: new Set([...prev.failedAssets, assetKey]),
        degradedMode: true, // Enter degraded mode if critical assets fail
      }));
    }
  }, [criticalAssets, requiredAssets]);

  // Button press handlers
  const handleButtonPressIn = () => {
    setIsButtonPressed(true);
  };

  const handleButtonPressOut = () => {
    setIsButtonPressed(false);
  };

  const handleGetStartedPress = useCallback(async () => {
    // Ensure button works before animations complete (Requirement 3.4)
    // Add navigation error handling and smooth transitions (Requirement 3.3, 4.6)
    
    try {
      // Set a timeout for navigation to prevent hanging
      navigationTimeoutRef.current = setTimeout(() => {
        ErrorLogger.logError(
          ErrorType.NAVIGATION_FAILURE,
          'Navigation timeout - forcing fallback',
          new Error('Navigation took too long')
        );
        
        // Show user feedback for navigation issues
        if (Platform.OS !== 'web') {
          Alert.alert(
            'Navigation Issue',
            'There was a problem navigating. Please try again.',
            [{ text: 'OK' }]
          );
        }
      }, 5000);

      const navigationSuccess = await safeNavigate(
        () => {
          if (navigationTimeoutRef.current) {
            clearTimeout(navigationTimeoutRef.current);
          }
          onGetStarted();
        },
        () => {
          // Fallback navigation - just call the function directly
          console.log('Using fallback navigation');
          onGetStarted();
        }
      );

      if (!navigationSuccess) {
        setFallbackState(prev => ({
          ...prev,
          hasNavigationErrors: true,
        }));
      }
    } catch (error) {
      ErrorLogger.logError(
        ErrorType.NAVIGATION_FAILURE,
        'Navigation failed in handleGetStartedPress',
        error as Error
      );
      
      // Still try to navigate as fallback
      onGetStarted();
    }
  }, [onGetStarted]);

  // Animated styles
  const logoAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ scale: logoScale.value }],
    };
  });

  const textAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: textTranslateX.value }],
      opacity: textOpacity.value,
    };
  });

  const pentagonAnimatedStyle = useAnimatedStyle(() => {
    return {
      opacity: pentagonShimmer.value,
    };
  });

  const groupAnimatedStyle = useAnimatedStyle(() => {
    const floatOffset = rs(5); // Responsive center offset
    return {
      transform: [{ translateY: groupFloatY.value - floatOffset }], // Center around original position
      opacity: groupShimmer.value,
    };
  });

  // Bubble animated styles - circular motion patterns
  const bubble1AnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: bubble1X.value },
        { translateY: bubble1Y.value },
      ],
    };
  });

  const bubble2AnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: bubble2X.value },
        { translateY: bubble2Y.value },
      ],
    };
  });

  const bubble3AnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: bubble3X.value },
        { translateY: bubble3Y.value },
      ],
    };
  });

  return (
    <View 
      style={styles.container}
      accessible={true}
      accessibilityRole={AccessibilityRoles.NONE}
      accessibilityLabel={AccessibilityLabels.SPLASH_SCREEN}
    >
      {/* Gradient Background */}
      <LinearGradient
        colors={['#FFB6C1', '#FFFFE0', '#98FB98', '#87CEEB', '#DDA0DD']}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
        style={styles.gradient}
      >
        {/* Floating Elements Layer */}
        <View style={styles.floatingElementsContainer}>
          {/* Pentagon Shape */}
          <Animated.View 
            style={[styles.pentagonContainer, pentagonAnimatedStyle]}
            accessible={true}
            accessibilityRole={AccessibilityRoles.IMAGE}
            accessibilityLabel={AccessibilityLabels.PENTAGON_DECORATION}
            importantForAccessibility={isScreenReaderEnabled ? 'no' : 'auto'}
          >
            <SafeImage
              assetKey="pentagon"
              style={styles.pentagonImage}
              onLoad={() => handleAssetLoad('pentagon')}
              onError={(error) => handleAssetError('pentagon', error)}
              resizeMode="contain"
              priority="low"
              enableRetry={!deviceCapabilities.isLowEndDevice}
            />
          </Animated.View>

          {/* Group Elements */}
          <Animated.View 
            style={[styles.groupContainer, groupAnimatedStyle]}
            accessible={true}
            accessibilityRole={AccessibilityRoles.IMAGE}
            accessibilityLabel={AccessibilityLabels.GROUP_DECORATION}
            importantForAccessibility={isScreenReaderEnabled ? 'no' : 'auto'}
          >
            <SafeImage
              assetKey="group"
              style={styles.groupImage}
              onLoad={() => handleAssetLoad('group')}
              onError={(error) => handleAssetError('group', error)}
              resizeMode="contain"
              priority="low"
              enableRetry={!deviceCapabilities.isLowEndDevice}
            />
          </Animated.View>

          {/* Bubbles */}
          <View 
            style={styles.bubblesContainer}
            accessible={false}
            importantForAccessibility="no-hide-descendants"
          >
            <Animated.View 
              style={[styles.bubble1, bubble1AnimatedStyle]}
              accessible={true}
              accessibilityRole={AccessibilityRoles.IMAGE}
              accessibilityLabel={AccessibilityLabels.BUBBLE_DECORATION}
              importantForAccessibility={isScreenReaderEnabled ? 'no' : 'auto'}
            >
              <SafeImage
                assetKey="bubble"
                style={styles.bubbleImage}
                onLoad={() => handleAssetLoad('bubble')}
                onError={(error) => handleAssetError('bubble', error)}
                resizeMode="contain"
                priority="low"
                enableRetry={false}
              />
            </Animated.View>
            <Animated.View 
              style={[styles.bubble2, bubble2AnimatedStyle]}
              accessible={true}
              accessibilityRole={AccessibilityRoles.IMAGE}
              accessibilityLabel={AccessibilityLabels.BUBBLE_DECORATION}
              importantForAccessibility={isScreenReaderEnabled ? 'no' : 'auto'}
            >
              <SafeImage
                assetKey="bubble"
                style={styles.bubbleImageSmall}
                resizeMode="contain"
                priority="low"
                enableRetry={false}
              />
            </Animated.View>
            <Animated.View 
              style={[styles.bubble3, bubble3AnimatedStyle]}
              accessible={true}
              accessibilityRole={AccessibilityRoles.IMAGE}
              accessibilityLabel={AccessibilityLabels.BUBBLE_DECORATION}
              importantForAccessibility={isScreenReaderEnabled ? 'no' : 'auto'}
            >
              <SafeImage
                assetKey="bubble"
                style={styles.bubbleImageMedium}
                resizeMode="contain"
                priority="low"
                enableRetry={false}
              />
            </Animated.View>
          </View>
        </View>

        {/* Main Content Layer */}
        <View style={styles.mainContentContainer}>
          {/* ZenZone Logo */}
          <Animated.View 
            style={[styles.logoContainer, logoAnimatedStyle]}
            accessible={true}
            accessibilityRole={AccessibilityRoles.IMAGE}
            accessibilityLabel={AccessibilityLabels.LOGO}
          >
            <SafeImage
              assetKey="logo"
              style={styles.logoImage}
              onLoad={() => handleAssetLoad('logo')}
              onError={(error) => handleAssetError('logo', error)}
              resizeMode="contain"
              priority="high"
              enableRetry={true}
              showFallbackText={true}
            />
          </Animated.View>

          {/* App Text */}
          <Animated.View 
            style={[styles.textContainer, textAnimatedStyle]}
            accessible={true}
            accessibilityRole={AccessibilityRoles.IMAGE}
            accessibilityLabel={AccessibilityLabels.APP_TEXT}
          >
            <SafeImage
              assetKey="text"
              style={styles.textImage}
              onLoad={() => handleAssetLoad('text')}
              onError={(error) => handleAssetError('text', error)}
              resizeMode="contain"
              priority="high"
              enableRetry={true}
              showFallbackText={true}
            />
          </Animated.View>


        </View>

        {/* Action Button Layer */}
        <View style={styles.actionButtonContainer}>
          {/* Gradient Border Container */}
          <LinearGradient
            colors={['rgba(255, 255, 255, 0.9)', 'rgba(255, 255, 255, 0.4)', 'rgba(255, 255, 255, 0.9)']}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
            style={styles.buttonGradientBorder}
          >
            <TouchableOpacity
              style={[
                styles.getStartedButton,
                isHighContrastEnabled && styles.getStartedButtonHighContrast,
                isButtonPressed && (isHighContrastEnabled ? styles.getStartedButtonHighContrastPressed : styles.getStartedButtonPressed)
              ]}
              onPress={handleGetStartedPress}
              onPressIn={handleButtonPressIn}
              onPressOut={handleButtonPressOut}
              activeOpacity={0.8}
              accessibilityRole={AccessibilityRoles.BUTTON}
              accessibilityLabel={AccessibilityLabels.GET_STARTED_BUTTON}
              accessibilityHint={AccessibilityLabels.GET_STARTED_HINT}
              accessibilityState={{ disabled: false }}
              accessible={true}
              focusable={true}
            >
              <Text style={[
                styles.getStartedButtonText,
                isHighContrastEnabled && styles.getStartedButtonTextHighContrast
              ]}>
                GET STARTED
              </Text>
            </TouchableOpacity>
          </LinearGradient>
        </View>
      </LinearGradient>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  gradient: {
    flex: 1,
    width: '100%',
    height: '100%',
  },
  floatingElementsContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 1,
  },
  mainContentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: wp(5), // Responsive horizontal padding (5% of screen width)
    zIndex: 2,
    // Adjust content positioning based on screen size
    paddingTop: screenCategory === 'small' ? hp(5) : hp(8),
  },
  actionButtonContainer: {
    position: 'absolute',
    bottom: hp(12), // Responsive bottom positioning (12% from bottom)
    left: wp(5), // Add side margins for better spacing
    right: wp(5),
    alignItems: 'center',
    zIndex: 3,
  },
  
  // Pentagon styles - responsive positioning and sizing
  pentagonContainer: {
    position: 'absolute',
    top: hp(8), // Responsive top positioning
    right: wp(8), // Responsive right positioning
    ...getPlatformShadow('medium'),
    shadowColor: '#FFB6C1',
  },
  pentagonImage: {
    ...getResponsiveDimensions(80, 80),
    // Adjust size based on screen category
    ...(screenCategory === 'small' && getResponsiveDimensions(60, 60)),
    ...(screenCategory === 'xlarge' && getResponsiveDimensions(100, 100)),
  },
  
  // Group styles - responsive positioning and sizing
  groupContainer: {
    position: 'absolute',
    top: hp(12), // Responsive top positioning
    left: wp(3), // Responsive left positioning
  },
  groupImage: {
    ...getResponsiveDimensions(100, 100),
    // Adjust size based on screen category
    ...(screenCategory === 'small' && getResponsiveDimensions(80, 80)),
    ...(screenCategory === 'xlarge' && getResponsiveDimensions(120, 120)),
  },
  
  // Bubble styles - responsive positioning and sizing
  bubblesContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  bubble1: {
    position: 'absolute',
    top: hp(25), // Responsive positioning
    left: wp(75), // Responsive positioning
  },
  bubble2: {
    position: 'absolute',
    top: hp(55), // Responsive positioning
    left: wp(8), // Responsive positioning
  },
  bubble3: {
    position: 'absolute',
    top: hp(65), // Responsive positioning
    right: wp(15), // Responsive positioning
  },
  bubbleImage: {
    ...getResponsiveDimensions(60, 60),
    // Adjust size based on screen category
    ...(screenCategory === 'small' && getResponsiveDimensions(45, 45)),
  },
  bubbleImageSmall: {
    ...getResponsiveDimensions(40, 40),
    // Adjust size based on screen category
    ...(screenCategory === 'small' && getResponsiveDimensions(30, 30)),
  },
  bubbleImageMedium: {
    ...getResponsiveDimensions(50, 50),
    // Adjust size based on screen category
    ...(screenCategory === 'small' && getResponsiveDimensions(38, 38)),
  },
  
  // Logo styles - responsive sizing
  logoContainer: {
    marginBottom: spacing.lg,
    alignItems: 'center',
  },
  logoImage: {
    ...getResponsiveDimensions(200, 120),
    // Adjust size based on screen category for better fit
    ...(screenCategory === 'small' && getResponsiveDimensions(160, 96)),
    ...(screenCategory === 'xlarge' && getResponsiveDimensions(240, 144)),
    maxWidth: wp(80), // Ensure it doesn't exceed 80% of screen width
  },
  
  // Text styles - responsive sizing (clean, no backdrop)
  textContainer: {
    marginBottom: spacing.md,
    alignItems: 'center',
  },
  textImage: {
    ...getResponsiveDimensions(250, 60),
    // Adjust size based on screen category
    ...(screenCategory === 'small' && getResponsiveDimensions(200, 48)),
    ...(screenCategory === 'xlarge' && getResponsiveDimensions(300, 72)),
    maxWidth: wp(85), // Ensure it doesn't exceed 85% of screen width
  },

  // Gradient border container for button
  buttonGradientBorder: {
    borderRadius: 25, // Fixed 25px border radius as requested
    padding: 3, // Creates the border thickness
    ...getPlatformShadow('medium'),
  },
  
  // Button styles - blue background with gradient border
  getStartedButton: {
    backgroundColor: '#4A90E2', // Blue background
    paddingHorizontal: wp(8), // Responsive horizontal padding
    paddingVertical: hp(1.8), // Responsive vertical padding
    borderRadius: 22, // Slightly smaller to account for gradient border padding
    minWidth: wp(40), // Minimum width for better touch target
    maxWidth: wp(80), // Maximum width to prevent stretching on large screens
    borderWidth: 0,
  },
  getStartedButtonPressed: {
    backgroundColor: '#357ABD', // Darker blue when pressed
    transform: [{ scale: 0.98 }], // Slightly less scale to account for gradient container
  },
  getStartedButtonHighContrast: {
    backgroundColor: AccessibleColors.BUTTON_BACKGROUND, // High contrast blue
    borderWidth: 2,
    borderColor: '#FFFFFF', // White border for better definition
  },
  getStartedButtonHighContrastPressed: {
    backgroundColor: AccessibleColors.BUTTON_BACKGROUND_PRESSED, // High contrast pressed state
    transform: [{ scale: 0.98 }],
  },
  getStartedButtonText: {
    fontSize: rf(18), // Responsive font size
    fontWeight: Platform.OS === 'web' ? '600' : '700', // Bold white text
    color: '#FFFFFF', // White text color
    textAlign: 'center',
    letterSpacing: Platform.OS === 'web' ? 0.8 : 1.2, // Slightly more letter spacing for readability
  },
  getStartedButtonTextHighContrast: {
    color: AccessibleColors.BUTTON_TEXT, // Ensure high contrast text
    fontWeight: Platform.OS === 'web' ? '700' : '800', // Even bolder for high contrast
  },

});

export default SplashScreen;